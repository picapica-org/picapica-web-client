// source: v1/configs.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

var v1_types_pb = require('../v1/types_pb.js');
goog.object.extend(proto, v1_types_pb);
goog.exportSymbol('proto.v1.AlignmentConfig', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Combinator', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Combinator.CombinatorCase', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Combinator.StringConcat', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Combinator.VectorConcat', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Extender', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Extender.Density', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Extender.ExtenderCase', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Extender.Range', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Mode', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Normalizer', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Normalizer.NormalizerCase', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Normalizer.Sorting', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Reducer', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Reducer.PassageLength', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Reducer.ReducerCase', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Seeder', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Seeder.Hash', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Seeder.Ngram', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Seeder.SeederCase', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Seeder.SmithWaterman', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Similarity', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Similarity.Cosine', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Similarity.Identity', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Similarity.Jaccard', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Similarity.Levenshtein', null, global);
goog.exportSymbol('proto.v1.AlignmentConfig.Similarity.SimilarityCase', null, global);
goog.exportSymbol('proto.v1.ApiConfig', null, global);
goog.exportSymbol('proto.v1.DecompositionConfig', null, global);
goog.exportSymbol('proto.v1.DecompositionConfig.Language', null, global);
goog.exportSymbol('proto.v1.DecompositionConfig.Representation', null, global);
goog.exportSymbol('proto.v1.RetrievalConfig', null, global);
goog.exportSymbol('proto.v1.SessionConfig', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.v1.ApiConfig = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.v1.ApiConfig, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.v1.ApiConfig.displayName = 'proto.v1.ApiConfig';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.v1.RetrievalConfig = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.v1.RetrievalConfig, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.v1.RetrievalConfig.displayName = 'proto.v1.RetrievalConfig';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.v1.DecompositionConfig = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.v1.DecompositionConfig, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.v1.DecompositionConfig.displayName = 'proto.v1.DecompositionConfig';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.v1.AlignmentConfig = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.v1.AlignmentConfig, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.v1.AlignmentConfig.displayName = 'proto.v1.AlignmentConfig';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.v1.AlignmentConfig.Seeder = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.v1.AlignmentConfig.Seeder.oneofGroups_);
};
goog.inherits(proto.v1.AlignmentConfig.Seeder, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.v1.AlignmentConfig.Seeder.displayName = 'proto.v1.AlignmentConfig.Seeder';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch.displayName = 'proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.v1.AlignmentConfig.Seeder.SmithWaterman = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.v1.AlignmentConfig.Seeder.SmithWaterman, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.v1.AlignmentConfig.Seeder.SmithWaterman.displayName = 'proto.v1.AlignmentConfig.Seeder.SmithWaterman';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.v1.AlignmentConfig.Seeder.Ngram = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.v1.AlignmentConfig.Seeder.Ngram, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.v1.AlignmentConfig.Seeder.Ngram.displayName = 'proto.v1.AlignmentConfig.Seeder.Ngram';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.v1.AlignmentConfig.Seeder.Hash = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.v1.AlignmentConfig.Seeder.Hash, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.v1.AlignmentConfig.Seeder.Hash.displayName = 'proto.v1.AlignmentConfig.Seeder.Hash';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.v1.AlignmentConfig.Extender = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.v1.AlignmentConfig.Extender.oneofGroups_);
};
goog.inherits(proto.v1.AlignmentConfig.Extender, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.v1.AlignmentConfig.Extender.displayName = 'proto.v1.AlignmentConfig.Extender';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.v1.AlignmentConfig.Extender.Density = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.v1.AlignmentConfig.Extender.Density, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.v1.AlignmentConfig.Extender.Density.displayName = 'proto.v1.AlignmentConfig.Extender.Density';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.v1.AlignmentConfig.Extender.Range = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.v1.AlignmentConfig.Extender.Range, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.v1.AlignmentConfig.Extender.Range.displayName = 'proto.v1.AlignmentConfig.Extender.Range';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.v1.AlignmentConfig.Reducer = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.v1.AlignmentConfig.Reducer.oneofGroups_);
};
goog.inherits(proto.v1.AlignmentConfig.Reducer, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.v1.AlignmentConfig.Reducer.displayName = 'proto.v1.AlignmentConfig.Reducer';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.v1.AlignmentConfig.Reducer.PassageLength = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.v1.AlignmentConfig.Reducer.PassageLength, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.v1.AlignmentConfig.Reducer.PassageLength.displayName = 'proto.v1.AlignmentConfig.Reducer.PassageLength';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.v1.AlignmentConfig.Similarity = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.v1.AlignmentConfig.Similarity.oneofGroups_);
};
goog.inherits(proto.v1.AlignmentConfig.Similarity, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.v1.AlignmentConfig.Similarity.displayName = 'proto.v1.AlignmentConfig.Similarity';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.v1.AlignmentConfig.Similarity.Identity = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.v1.AlignmentConfig.Similarity.Identity, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.v1.AlignmentConfig.Similarity.Identity.displayName = 'proto.v1.AlignmentConfig.Similarity.Identity';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.v1.AlignmentConfig.Similarity.Cosine = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.v1.AlignmentConfig.Similarity.Cosine, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.v1.AlignmentConfig.Similarity.Cosine.displayName = 'proto.v1.AlignmentConfig.Similarity.Cosine';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.v1.AlignmentConfig.Similarity.Levenshtein = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.v1.AlignmentConfig.Similarity.Levenshtein, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.v1.AlignmentConfig.Similarity.Levenshtein.displayName = 'proto.v1.AlignmentConfig.Similarity.Levenshtein';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.v1.AlignmentConfig.Similarity.Jaccard = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.v1.AlignmentConfig.Similarity.Jaccard, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.v1.AlignmentConfig.Similarity.Jaccard.displayName = 'proto.v1.AlignmentConfig.Similarity.Jaccard';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.v1.AlignmentConfig.Combinator = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.v1.AlignmentConfig.Combinator.oneofGroups_);
};
goog.inherits(proto.v1.AlignmentConfig.Combinator, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.v1.AlignmentConfig.Combinator.displayName = 'proto.v1.AlignmentConfig.Combinator';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.v1.AlignmentConfig.Combinator.StringConcat = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.v1.AlignmentConfig.Combinator.StringConcat, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.v1.AlignmentConfig.Combinator.StringConcat.displayName = 'proto.v1.AlignmentConfig.Combinator.StringConcat';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.v1.AlignmentConfig.Combinator.VectorConcat = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.v1.AlignmentConfig.Combinator.VectorConcat, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.v1.AlignmentConfig.Combinator.VectorConcat.displayName = 'proto.v1.AlignmentConfig.Combinator.VectorConcat';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.v1.AlignmentConfig.Normalizer = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.v1.AlignmentConfig.Normalizer.oneofGroups_);
};
goog.inherits(proto.v1.AlignmentConfig.Normalizer, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.v1.AlignmentConfig.Normalizer.displayName = 'proto.v1.AlignmentConfig.Normalizer';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.v1.AlignmentConfig.Normalizer.Sorting = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.v1.AlignmentConfig.Normalizer.Sorting, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.v1.AlignmentConfig.Normalizer.Sorting.displayName = 'proto.v1.AlignmentConfig.Normalizer.Sorting';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.v1.SessionConfig = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.v1.SessionConfig.repeatedFields_, null);
};
goog.inherits(proto.v1.SessionConfig, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.v1.SessionConfig.displayName = 'proto.v1.SessionConfig';
}



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.v1.ApiConfig.prototype.toObject = function(opt_includeInstance) {
  return proto.v1.ApiConfig.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.v1.ApiConfig} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.ApiConfig.toObject = function(includeInstance, msg) {
  var f, obj = {
    retrieval: (f = msg.getRetrieval()) && proto.v1.RetrievalConfig.toObject(includeInstance, f),
    decomposition: (f = msg.getDecomposition()) && proto.v1.DecompositionConfig.toObject(includeInstance, f),
    alignment: (f = msg.getAlignment()) && proto.v1.AlignmentConfig.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.v1.ApiConfig}
 */
proto.v1.ApiConfig.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.v1.ApiConfig;
  return proto.v1.ApiConfig.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.v1.ApiConfig} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.v1.ApiConfig}
 */
proto.v1.ApiConfig.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.v1.RetrievalConfig;
      reader.readMessage(value,proto.v1.RetrievalConfig.deserializeBinaryFromReader);
      msg.setRetrieval(value);
      break;
    case 2:
      var value = new proto.v1.DecompositionConfig;
      reader.readMessage(value,proto.v1.DecompositionConfig.deserializeBinaryFromReader);
      msg.setDecomposition(value);
      break;
    case 3:
      var value = new proto.v1.AlignmentConfig;
      reader.readMessage(value,proto.v1.AlignmentConfig.deserializeBinaryFromReader);
      msg.setAlignment(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.v1.ApiConfig.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.v1.ApiConfig.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.v1.ApiConfig} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.ApiConfig.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRetrieval();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.v1.RetrievalConfig.serializeBinaryToWriter
    );
  }
  f = message.getDecomposition();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.v1.DecompositionConfig.serializeBinaryToWriter
    );
  }
  f = message.getAlignment();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.v1.AlignmentConfig.serializeBinaryToWriter
    );
  }
};


/**
 * optional RetrievalConfig retrieval = 1;
 * @return {?proto.v1.RetrievalConfig}
 */
proto.v1.ApiConfig.prototype.getRetrieval = function() {
  return /** @type{?proto.v1.RetrievalConfig} */ (
    jspb.Message.getWrapperField(this, proto.v1.RetrievalConfig, 1));
};


/**
 * @param {?proto.v1.RetrievalConfig|undefined} value
 * @return {!proto.v1.ApiConfig} returns this
*/
proto.v1.ApiConfig.prototype.setRetrieval = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.v1.ApiConfig} returns this
 */
proto.v1.ApiConfig.prototype.clearRetrieval = function() {
  return this.setRetrieval(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.v1.ApiConfig.prototype.hasRetrieval = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional DecompositionConfig decomposition = 2;
 * @return {?proto.v1.DecompositionConfig}
 */
proto.v1.ApiConfig.prototype.getDecomposition = function() {
  return /** @type{?proto.v1.DecompositionConfig} */ (
    jspb.Message.getWrapperField(this, proto.v1.DecompositionConfig, 2));
};


/**
 * @param {?proto.v1.DecompositionConfig|undefined} value
 * @return {!proto.v1.ApiConfig} returns this
*/
proto.v1.ApiConfig.prototype.setDecomposition = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.v1.ApiConfig} returns this
 */
proto.v1.ApiConfig.prototype.clearDecomposition = function() {
  return this.setDecomposition(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.v1.ApiConfig.prototype.hasDecomposition = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional AlignmentConfig alignment = 3;
 * @return {?proto.v1.AlignmentConfig}
 */
proto.v1.ApiConfig.prototype.getAlignment = function() {
  return /** @type{?proto.v1.AlignmentConfig} */ (
    jspb.Message.getWrapperField(this, proto.v1.AlignmentConfig, 3));
};


/**
 * @param {?proto.v1.AlignmentConfig|undefined} value
 * @return {!proto.v1.ApiConfig} returns this
*/
proto.v1.ApiConfig.prototype.setAlignment = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.v1.ApiConfig} returns this
 */
proto.v1.ApiConfig.prototype.clearAlignment = function() {
  return this.setAlignment(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.v1.ApiConfig.prototype.hasAlignment = function() {
  return jspb.Message.getField(this, 3) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.v1.RetrievalConfig.prototype.toObject = function(opt_includeInstance) {
  return proto.v1.RetrievalConfig.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.v1.RetrievalConfig} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.RetrievalConfig.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.v1.RetrievalConfig}
 */
proto.v1.RetrievalConfig.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.v1.RetrievalConfig;
  return proto.v1.RetrievalConfig.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.v1.RetrievalConfig} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.v1.RetrievalConfig}
 */
proto.v1.RetrievalConfig.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.v1.RetrievalConfig.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.v1.RetrievalConfig.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.v1.RetrievalConfig} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.RetrievalConfig.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.v1.DecompositionConfig.prototype.toObject = function(opt_includeInstance) {
  return proto.v1.DecompositionConfig.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.v1.DecompositionConfig} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.DecompositionConfig.toObject = function(includeInstance, msg) {
  var f, obj = {
    representation: jspb.Message.getFieldWithDefault(msg, 1, 0),
    language: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.v1.DecompositionConfig}
 */
proto.v1.DecompositionConfig.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.v1.DecompositionConfig;
  return proto.v1.DecompositionConfig.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.v1.DecompositionConfig} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.v1.DecompositionConfig}
 */
proto.v1.DecompositionConfig.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.v1.DecompositionConfig.Representation} */ (reader.readEnum());
      msg.setRepresentation(value);
      break;
    case 2:
      var value = /** @type {!proto.v1.DecompositionConfig.Language} */ (reader.readEnum());
      msg.setLanguage(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.v1.DecompositionConfig.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.v1.DecompositionConfig.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.v1.DecompositionConfig} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.DecompositionConfig.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRepresentation();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getLanguage();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.v1.DecompositionConfig.Representation = {
  REPRESENTATION_UNSPECIFIED: 0,
  REPRESENTATION_TOKEN: 1,
  REPRESENTATION_VECTOR: 2,
  REPRESENTATION_POS: 3,
  REPRESENTATION_LEMMA: 4
};

/**
 * @enum {number}
 */
proto.v1.DecompositionConfig.Language = {
  LANGUAGE_UNSPECIFIED: 0,
  LANGUAGE_EN: 1,
  LANGUAGE_DE: 2,
  LANGUAGE_FR: 3
};

/**
 * optional Representation representation = 1;
 * @return {!proto.v1.DecompositionConfig.Representation}
 */
proto.v1.DecompositionConfig.prototype.getRepresentation = function() {
  return /** @type {!proto.v1.DecompositionConfig.Representation} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.v1.DecompositionConfig.Representation} value
 * @return {!proto.v1.DecompositionConfig} returns this
 */
proto.v1.DecompositionConfig.prototype.setRepresentation = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional Language language = 2;
 * @return {!proto.v1.DecompositionConfig.Language}
 */
proto.v1.DecompositionConfig.prototype.getLanguage = function() {
  return /** @type {!proto.v1.DecompositionConfig.Language} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {!proto.v1.DecompositionConfig.Language} value
 * @return {!proto.v1.DecompositionConfig} returns this
 */
proto.v1.DecompositionConfig.prototype.setLanguage = function(value) {
  return jspb.Message.setProto3EnumField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.v1.AlignmentConfig.prototype.toObject = function(opt_includeInstance) {
  return proto.v1.AlignmentConfig.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.v1.AlignmentConfig} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.toObject = function(includeInstance, msg) {
  var f, obj = {
    mode: jspb.Message.getFieldWithDefault(msg, 1, 0),
    seeder: (f = msg.getSeeder()) && proto.v1.AlignmentConfig.Seeder.toObject(includeInstance, f),
    extender: (f = msg.getExtender()) && proto.v1.AlignmentConfig.Extender.toObject(includeInstance, f),
    reducer: (f = msg.getReducer()) && proto.v1.AlignmentConfig.Reducer.toObject(includeInstance, f),
    similarity: (f = msg.getSimilarity()) && proto.v1.AlignmentConfig.Similarity.toObject(includeInstance, f),
    combinator: (f = msg.getCombinator()) && proto.v1.AlignmentConfig.Combinator.toObject(includeInstance, f),
    normalizer: (f = msg.getNormalizer()) && proto.v1.AlignmentConfig.Normalizer.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.v1.AlignmentConfig}
 */
proto.v1.AlignmentConfig.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.v1.AlignmentConfig;
  return proto.v1.AlignmentConfig.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.v1.AlignmentConfig} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.v1.AlignmentConfig}
 */
proto.v1.AlignmentConfig.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.v1.AlignmentConfig.Mode} */ (reader.readEnum());
      msg.setMode(value);
      break;
    case 2:
      var value = new proto.v1.AlignmentConfig.Seeder;
      reader.readMessage(value,proto.v1.AlignmentConfig.Seeder.deserializeBinaryFromReader);
      msg.setSeeder(value);
      break;
    case 3:
      var value = new proto.v1.AlignmentConfig.Extender;
      reader.readMessage(value,proto.v1.AlignmentConfig.Extender.deserializeBinaryFromReader);
      msg.setExtender(value);
      break;
    case 4:
      var value = new proto.v1.AlignmentConfig.Reducer;
      reader.readMessage(value,proto.v1.AlignmentConfig.Reducer.deserializeBinaryFromReader);
      msg.setReducer(value);
      break;
    case 5:
      var value = new proto.v1.AlignmentConfig.Similarity;
      reader.readMessage(value,proto.v1.AlignmentConfig.Similarity.deserializeBinaryFromReader);
      msg.setSimilarity(value);
      break;
    case 6:
      var value = new proto.v1.AlignmentConfig.Combinator;
      reader.readMessage(value,proto.v1.AlignmentConfig.Combinator.deserializeBinaryFromReader);
      msg.setCombinator(value);
      break;
    case 7:
      var value = new proto.v1.AlignmentConfig.Normalizer;
      reader.readMessage(value,proto.v1.AlignmentConfig.Normalizer.deserializeBinaryFromReader);
      msg.setNormalizer(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.v1.AlignmentConfig.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.v1.AlignmentConfig.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.v1.AlignmentConfig} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMode();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getSeeder();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.v1.AlignmentConfig.Seeder.serializeBinaryToWriter
    );
  }
  f = message.getExtender();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.v1.AlignmentConfig.Extender.serializeBinaryToWriter
    );
  }
  f = message.getReducer();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.v1.AlignmentConfig.Reducer.serializeBinaryToWriter
    );
  }
  f = message.getSimilarity();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.v1.AlignmentConfig.Similarity.serializeBinaryToWriter
    );
  }
  f = message.getCombinator();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.v1.AlignmentConfig.Combinator.serializeBinaryToWriter
    );
  }
  f = message.getNormalizer();
  if (f != null) {
    writer.writeMessage(
      7,
      f,
      proto.v1.AlignmentConfig.Normalizer.serializeBinaryToWriter
    );
  }
};


/**
 * @enum {number}
 */
proto.v1.AlignmentConfig.Mode = {
  MODE_UNSPECIFIED: 0,
  MODE_STRING: 1,
  MODE_VECTOR: 2
};


/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.v1.AlignmentConfig.Seeder.oneofGroups_ = [[1,2,3,4]];

/**
 * @enum {number}
 */
proto.v1.AlignmentConfig.Seeder.SeederCase = {
  SEEDER_NOT_SET: 0,
  NEEDLEMAN_WUNSCH: 1,
  SMITH_WATERMAN: 2,
  NGRAM: 3,
  HASH: 4
};

/**
 * @return {proto.v1.AlignmentConfig.Seeder.SeederCase}
 */
proto.v1.AlignmentConfig.Seeder.prototype.getSeederCase = function() {
  return /** @type {proto.v1.AlignmentConfig.Seeder.SeederCase} */(jspb.Message.computeOneofCase(this, proto.v1.AlignmentConfig.Seeder.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.v1.AlignmentConfig.Seeder.prototype.toObject = function(opt_includeInstance) {
  return proto.v1.AlignmentConfig.Seeder.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.v1.AlignmentConfig.Seeder} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Seeder.toObject = function(includeInstance, msg) {
  var f, obj = {
    needlemanWunsch: (f = msg.getNeedlemanWunsch()) && proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch.toObject(includeInstance, f),
    smithWaterman: (f = msg.getSmithWaterman()) && proto.v1.AlignmentConfig.Seeder.SmithWaterman.toObject(includeInstance, f),
    ngram: (f = msg.getNgram()) && proto.v1.AlignmentConfig.Seeder.Ngram.toObject(includeInstance, f),
    hash: (f = msg.getHash()) && proto.v1.AlignmentConfig.Seeder.Hash.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.v1.AlignmentConfig.Seeder}
 */
proto.v1.AlignmentConfig.Seeder.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.v1.AlignmentConfig.Seeder;
  return proto.v1.AlignmentConfig.Seeder.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.v1.AlignmentConfig.Seeder} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.v1.AlignmentConfig.Seeder}
 */
proto.v1.AlignmentConfig.Seeder.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch;
      reader.readMessage(value,proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch.deserializeBinaryFromReader);
      msg.setNeedlemanWunsch(value);
      break;
    case 2:
      var value = new proto.v1.AlignmentConfig.Seeder.SmithWaterman;
      reader.readMessage(value,proto.v1.AlignmentConfig.Seeder.SmithWaterman.deserializeBinaryFromReader);
      msg.setSmithWaterman(value);
      break;
    case 3:
      var value = new proto.v1.AlignmentConfig.Seeder.Ngram;
      reader.readMessage(value,proto.v1.AlignmentConfig.Seeder.Ngram.deserializeBinaryFromReader);
      msg.setNgram(value);
      break;
    case 4:
      var value = new proto.v1.AlignmentConfig.Seeder.Hash;
      reader.readMessage(value,proto.v1.AlignmentConfig.Seeder.Hash.deserializeBinaryFromReader);
      msg.setHash(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.v1.AlignmentConfig.Seeder.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.v1.AlignmentConfig.Seeder.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.v1.AlignmentConfig.Seeder} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Seeder.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNeedlemanWunsch();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch.serializeBinaryToWriter
    );
  }
  f = message.getSmithWaterman();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.v1.AlignmentConfig.Seeder.SmithWaterman.serializeBinaryToWriter
    );
  }
  f = message.getNgram();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.v1.AlignmentConfig.Seeder.Ngram.serializeBinaryToWriter
    );
  }
  f = message.getHash();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.v1.AlignmentConfig.Seeder.Hash.serializeBinaryToWriter
    );
  }
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch.prototype.toObject = function(opt_includeInstance) {
  return proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch.toObject = function(includeInstance, msg) {
  var f, obj = {
    mismatchCost: jspb.Message.getFloatingPointFieldWithDefault(msg, 1, 0.0),
    gapCost: jspb.Message.getFloatingPointFieldWithDefault(msg, 2, 0.0),
    matchAward: jspb.Message.getFloatingPointFieldWithDefault(msg, 3, 0.0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch}
 */
proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch;
  return proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch}
 */
proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setMismatchCost(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setGapCost(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setMatchAward(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMismatchCost();
  if (f !== 0.0) {
    writer.writeFloat(
      1,
      f
    );
  }
  f = message.getGapCost();
  if (f !== 0.0) {
    writer.writeFloat(
      2,
      f
    );
  }
  f = message.getMatchAward();
  if (f !== 0.0) {
    writer.writeFloat(
      3,
      f
    );
  }
};


/**
 * optional float mismatch_cost = 1;
 * @return {number}
 */
proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch.prototype.getMismatchCost = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 1, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch} returns this
 */
proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch.prototype.setMismatchCost = function(value) {
  return jspb.Message.setProto3FloatField(this, 1, value);
};


/**
 * optional float gap_cost = 2;
 * @return {number}
 */
proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch.prototype.getGapCost = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 2, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch} returns this
 */
proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch.prototype.setGapCost = function(value) {
  return jspb.Message.setProto3FloatField(this, 2, value);
};


/**
 * optional float match_award = 3;
 * @return {number}
 */
proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch.prototype.getMatchAward = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 3, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch} returns this
 */
proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch.prototype.setMatchAward = function(value) {
  return jspb.Message.setProto3FloatField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.v1.AlignmentConfig.Seeder.SmithWaterman.prototype.toObject = function(opt_includeInstance) {
  return proto.v1.AlignmentConfig.Seeder.SmithWaterman.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.v1.AlignmentConfig.Seeder.SmithWaterman} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Seeder.SmithWaterman.toObject = function(includeInstance, msg) {
  var f, obj = {
    mismatchCost: jspb.Message.getFloatingPointFieldWithDefault(msg, 1, 0.0),
    gapCost: jspb.Message.getFloatingPointFieldWithDefault(msg, 2, 0.0),
    matchAward: jspb.Message.getFloatingPointFieldWithDefault(msg, 3, 0.0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.v1.AlignmentConfig.Seeder.SmithWaterman}
 */
proto.v1.AlignmentConfig.Seeder.SmithWaterman.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.v1.AlignmentConfig.Seeder.SmithWaterman;
  return proto.v1.AlignmentConfig.Seeder.SmithWaterman.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.v1.AlignmentConfig.Seeder.SmithWaterman} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.v1.AlignmentConfig.Seeder.SmithWaterman}
 */
proto.v1.AlignmentConfig.Seeder.SmithWaterman.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setMismatchCost(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setGapCost(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setMatchAward(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.v1.AlignmentConfig.Seeder.SmithWaterman.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.v1.AlignmentConfig.Seeder.SmithWaterman.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.v1.AlignmentConfig.Seeder.SmithWaterman} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Seeder.SmithWaterman.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMismatchCost();
  if (f !== 0.0) {
    writer.writeFloat(
      1,
      f
    );
  }
  f = message.getGapCost();
  if (f !== 0.0) {
    writer.writeFloat(
      2,
      f
    );
  }
  f = message.getMatchAward();
  if (f !== 0.0) {
    writer.writeFloat(
      3,
      f
    );
  }
};


/**
 * optional float mismatch_cost = 1;
 * @return {number}
 */
proto.v1.AlignmentConfig.Seeder.SmithWaterman.prototype.getMismatchCost = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 1, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.v1.AlignmentConfig.Seeder.SmithWaterman} returns this
 */
proto.v1.AlignmentConfig.Seeder.SmithWaterman.prototype.setMismatchCost = function(value) {
  return jspb.Message.setProto3FloatField(this, 1, value);
};


/**
 * optional float gap_cost = 2;
 * @return {number}
 */
proto.v1.AlignmentConfig.Seeder.SmithWaterman.prototype.getGapCost = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 2, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.v1.AlignmentConfig.Seeder.SmithWaterman} returns this
 */
proto.v1.AlignmentConfig.Seeder.SmithWaterman.prototype.setGapCost = function(value) {
  return jspb.Message.setProto3FloatField(this, 2, value);
};


/**
 * optional float match_award = 3;
 * @return {number}
 */
proto.v1.AlignmentConfig.Seeder.SmithWaterman.prototype.getMatchAward = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 3, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.v1.AlignmentConfig.Seeder.SmithWaterman} returns this
 */
proto.v1.AlignmentConfig.Seeder.SmithWaterman.prototype.setMatchAward = function(value) {
  return jspb.Message.setProto3FloatField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.v1.AlignmentConfig.Seeder.Ngram.prototype.toObject = function(opt_includeInstance) {
  return proto.v1.AlignmentConfig.Seeder.Ngram.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.v1.AlignmentConfig.Seeder.Ngram} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Seeder.Ngram.toObject = function(includeInstance, msg) {
  var f, obj = {
    n: jspb.Message.getFieldWithDefault(msg, 1, 0),
    overlap: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.v1.AlignmentConfig.Seeder.Ngram}
 */
proto.v1.AlignmentConfig.Seeder.Ngram.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.v1.AlignmentConfig.Seeder.Ngram;
  return proto.v1.AlignmentConfig.Seeder.Ngram.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.v1.AlignmentConfig.Seeder.Ngram} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.v1.AlignmentConfig.Seeder.Ngram}
 */
proto.v1.AlignmentConfig.Seeder.Ngram.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setN(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setOverlap(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.v1.AlignmentConfig.Seeder.Ngram.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.v1.AlignmentConfig.Seeder.Ngram.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.v1.AlignmentConfig.Seeder.Ngram} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Seeder.Ngram.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getN();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getOverlap();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
};


/**
 * optional uint32 n = 1;
 * @return {number}
 */
proto.v1.AlignmentConfig.Seeder.Ngram.prototype.getN = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.v1.AlignmentConfig.Seeder.Ngram} returns this
 */
proto.v1.AlignmentConfig.Seeder.Ngram.prototype.setN = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional uint32 overlap = 2;
 * @return {number}
 */
proto.v1.AlignmentConfig.Seeder.Ngram.prototype.getOverlap = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.v1.AlignmentConfig.Seeder.Ngram} returns this
 */
proto.v1.AlignmentConfig.Seeder.Ngram.prototype.setOverlap = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.v1.AlignmentConfig.Seeder.Hash.prototype.toObject = function(opt_includeInstance) {
  return proto.v1.AlignmentConfig.Seeder.Hash.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.v1.AlignmentConfig.Seeder.Hash} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Seeder.Hash.toObject = function(includeInstance, msg) {
  var f, obj = {
    n: jspb.Message.getFieldWithDefault(msg, 1, 0),
    overlap: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.v1.AlignmentConfig.Seeder.Hash}
 */
proto.v1.AlignmentConfig.Seeder.Hash.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.v1.AlignmentConfig.Seeder.Hash;
  return proto.v1.AlignmentConfig.Seeder.Hash.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.v1.AlignmentConfig.Seeder.Hash} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.v1.AlignmentConfig.Seeder.Hash}
 */
proto.v1.AlignmentConfig.Seeder.Hash.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setN(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setOverlap(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.v1.AlignmentConfig.Seeder.Hash.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.v1.AlignmentConfig.Seeder.Hash.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.v1.AlignmentConfig.Seeder.Hash} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Seeder.Hash.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getN();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getOverlap();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
};


/**
 * optional uint32 n = 1;
 * @return {number}
 */
proto.v1.AlignmentConfig.Seeder.Hash.prototype.getN = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.v1.AlignmentConfig.Seeder.Hash} returns this
 */
proto.v1.AlignmentConfig.Seeder.Hash.prototype.setN = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional uint32 overlap = 2;
 * @return {number}
 */
proto.v1.AlignmentConfig.Seeder.Hash.prototype.getOverlap = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.v1.AlignmentConfig.Seeder.Hash} returns this
 */
proto.v1.AlignmentConfig.Seeder.Hash.prototype.setOverlap = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional NeedlemanWunsch needleman_wunsch = 1;
 * @return {?proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch}
 */
proto.v1.AlignmentConfig.Seeder.prototype.getNeedlemanWunsch = function() {
  return /** @type{?proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch} */ (
    jspb.Message.getWrapperField(this, proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch, 1));
};


/**
 * @param {?proto.v1.AlignmentConfig.Seeder.NeedlemanWunsch|undefined} value
 * @return {!proto.v1.AlignmentConfig.Seeder} returns this
*/
proto.v1.AlignmentConfig.Seeder.prototype.setNeedlemanWunsch = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1, proto.v1.AlignmentConfig.Seeder.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.v1.AlignmentConfig.Seeder} returns this
 */
proto.v1.AlignmentConfig.Seeder.prototype.clearNeedlemanWunsch = function() {
  return this.setNeedlemanWunsch(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.v1.AlignmentConfig.Seeder.prototype.hasNeedlemanWunsch = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional SmithWaterman smith_waterman = 2;
 * @return {?proto.v1.AlignmentConfig.Seeder.SmithWaterman}
 */
proto.v1.AlignmentConfig.Seeder.prototype.getSmithWaterman = function() {
  return /** @type{?proto.v1.AlignmentConfig.Seeder.SmithWaterman} */ (
    jspb.Message.getWrapperField(this, proto.v1.AlignmentConfig.Seeder.SmithWaterman, 2));
};


/**
 * @param {?proto.v1.AlignmentConfig.Seeder.SmithWaterman|undefined} value
 * @return {!proto.v1.AlignmentConfig.Seeder} returns this
*/
proto.v1.AlignmentConfig.Seeder.prototype.setSmithWaterman = function(value) {
  return jspb.Message.setOneofWrapperField(this, 2, proto.v1.AlignmentConfig.Seeder.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.v1.AlignmentConfig.Seeder} returns this
 */
proto.v1.AlignmentConfig.Seeder.prototype.clearSmithWaterman = function() {
  return this.setSmithWaterman(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.v1.AlignmentConfig.Seeder.prototype.hasSmithWaterman = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional Ngram ngram = 3;
 * @return {?proto.v1.AlignmentConfig.Seeder.Ngram}
 */
proto.v1.AlignmentConfig.Seeder.prototype.getNgram = function() {
  return /** @type{?proto.v1.AlignmentConfig.Seeder.Ngram} */ (
    jspb.Message.getWrapperField(this, proto.v1.AlignmentConfig.Seeder.Ngram, 3));
};


/**
 * @param {?proto.v1.AlignmentConfig.Seeder.Ngram|undefined} value
 * @return {!proto.v1.AlignmentConfig.Seeder} returns this
*/
proto.v1.AlignmentConfig.Seeder.prototype.setNgram = function(value) {
  return jspb.Message.setOneofWrapperField(this, 3, proto.v1.AlignmentConfig.Seeder.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.v1.AlignmentConfig.Seeder} returns this
 */
proto.v1.AlignmentConfig.Seeder.prototype.clearNgram = function() {
  return this.setNgram(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.v1.AlignmentConfig.Seeder.prototype.hasNgram = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional Hash hash = 4;
 * @return {?proto.v1.AlignmentConfig.Seeder.Hash}
 */
proto.v1.AlignmentConfig.Seeder.prototype.getHash = function() {
  return /** @type{?proto.v1.AlignmentConfig.Seeder.Hash} */ (
    jspb.Message.getWrapperField(this, proto.v1.AlignmentConfig.Seeder.Hash, 4));
};


/**
 * @param {?proto.v1.AlignmentConfig.Seeder.Hash|undefined} value
 * @return {!proto.v1.AlignmentConfig.Seeder} returns this
*/
proto.v1.AlignmentConfig.Seeder.prototype.setHash = function(value) {
  return jspb.Message.setOneofWrapperField(this, 4, proto.v1.AlignmentConfig.Seeder.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.v1.AlignmentConfig.Seeder} returns this
 */
proto.v1.AlignmentConfig.Seeder.prototype.clearHash = function() {
  return this.setHash(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.v1.AlignmentConfig.Seeder.prototype.hasHash = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.v1.AlignmentConfig.Extender.oneofGroups_ = [[1,2]];

/**
 * @enum {number}
 */
proto.v1.AlignmentConfig.Extender.ExtenderCase = {
  EXTENDER_NOT_SET: 0,
  DENSITY: 1,
  RANGE: 2
};

/**
 * @return {proto.v1.AlignmentConfig.Extender.ExtenderCase}
 */
proto.v1.AlignmentConfig.Extender.prototype.getExtenderCase = function() {
  return /** @type {proto.v1.AlignmentConfig.Extender.ExtenderCase} */(jspb.Message.computeOneofCase(this, proto.v1.AlignmentConfig.Extender.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.v1.AlignmentConfig.Extender.prototype.toObject = function(opt_includeInstance) {
  return proto.v1.AlignmentConfig.Extender.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.v1.AlignmentConfig.Extender} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Extender.toObject = function(includeInstance, msg) {
  var f, obj = {
    density: (f = msg.getDensity()) && proto.v1.AlignmentConfig.Extender.Density.toObject(includeInstance, f),
    range: (f = msg.getRange()) && proto.v1.AlignmentConfig.Extender.Range.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.v1.AlignmentConfig.Extender}
 */
proto.v1.AlignmentConfig.Extender.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.v1.AlignmentConfig.Extender;
  return proto.v1.AlignmentConfig.Extender.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.v1.AlignmentConfig.Extender} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.v1.AlignmentConfig.Extender}
 */
proto.v1.AlignmentConfig.Extender.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.v1.AlignmentConfig.Extender.Density;
      reader.readMessage(value,proto.v1.AlignmentConfig.Extender.Density.deserializeBinaryFromReader);
      msg.setDensity(value);
      break;
    case 2:
      var value = new proto.v1.AlignmentConfig.Extender.Range;
      reader.readMessage(value,proto.v1.AlignmentConfig.Extender.Range.deserializeBinaryFromReader);
      msg.setRange(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.v1.AlignmentConfig.Extender.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.v1.AlignmentConfig.Extender.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.v1.AlignmentConfig.Extender} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Extender.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getDensity();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.v1.AlignmentConfig.Extender.Density.serializeBinaryToWriter
    );
  }
  f = message.getRange();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.v1.AlignmentConfig.Extender.Range.serializeBinaryToWriter
    );
  }
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.v1.AlignmentConfig.Extender.Density.prototype.toObject = function(opt_includeInstance) {
  return proto.v1.AlignmentConfig.Extender.Density.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.v1.AlignmentConfig.Extender.Density} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Extender.Density.toObject = function(includeInstance, msg) {
  var f, obj = {
    minPoints: jspb.Message.getFieldWithDefault(msg, 1, 0),
    epsilon: jspb.Message.getFloatingPointFieldWithDefault(msg, 2, 0.0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.v1.AlignmentConfig.Extender.Density}
 */
proto.v1.AlignmentConfig.Extender.Density.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.v1.AlignmentConfig.Extender.Density;
  return proto.v1.AlignmentConfig.Extender.Density.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.v1.AlignmentConfig.Extender.Density} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.v1.AlignmentConfig.Extender.Density}
 */
proto.v1.AlignmentConfig.Extender.Density.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setMinPoints(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setEpsilon(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.v1.AlignmentConfig.Extender.Density.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.v1.AlignmentConfig.Extender.Density.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.v1.AlignmentConfig.Extender.Density} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Extender.Density.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMinPoints();
  if (f !== 0) {
    writer.writeInt32(
      1,
      f
    );
  }
  f = message.getEpsilon();
  if (f !== 0.0) {
    writer.writeFloat(
      2,
      f
    );
  }
};


/**
 * optional int32 min_points = 1;
 * @return {number}
 */
proto.v1.AlignmentConfig.Extender.Density.prototype.getMinPoints = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.v1.AlignmentConfig.Extender.Density} returns this
 */
proto.v1.AlignmentConfig.Extender.Density.prototype.setMinPoints = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional float epsilon = 2;
 * @return {number}
 */
proto.v1.AlignmentConfig.Extender.Density.prototype.getEpsilon = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 2, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.v1.AlignmentConfig.Extender.Density} returns this
 */
proto.v1.AlignmentConfig.Extender.Density.prototype.setEpsilon = function(value) {
  return jspb.Message.setProto3FloatField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.v1.AlignmentConfig.Extender.Range.prototype.toObject = function(opt_includeInstance) {
  return proto.v1.AlignmentConfig.Extender.Range.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.v1.AlignmentConfig.Extender.Range} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Extender.Range.toObject = function(includeInstance, msg) {
  var f, obj = {
    theta: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.v1.AlignmentConfig.Extender.Range}
 */
proto.v1.AlignmentConfig.Extender.Range.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.v1.AlignmentConfig.Extender.Range;
  return proto.v1.AlignmentConfig.Extender.Range.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.v1.AlignmentConfig.Extender.Range} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.v1.AlignmentConfig.Extender.Range}
 */
proto.v1.AlignmentConfig.Extender.Range.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setTheta(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.v1.AlignmentConfig.Extender.Range.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.v1.AlignmentConfig.Extender.Range.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.v1.AlignmentConfig.Extender.Range} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Extender.Range.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTheta();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 theta = 1;
 * @return {number}
 */
proto.v1.AlignmentConfig.Extender.Range.prototype.getTheta = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.v1.AlignmentConfig.Extender.Range} returns this
 */
proto.v1.AlignmentConfig.Extender.Range.prototype.setTheta = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional Density density = 1;
 * @return {?proto.v1.AlignmentConfig.Extender.Density}
 */
proto.v1.AlignmentConfig.Extender.prototype.getDensity = function() {
  return /** @type{?proto.v1.AlignmentConfig.Extender.Density} */ (
    jspb.Message.getWrapperField(this, proto.v1.AlignmentConfig.Extender.Density, 1));
};


/**
 * @param {?proto.v1.AlignmentConfig.Extender.Density|undefined} value
 * @return {!proto.v1.AlignmentConfig.Extender} returns this
*/
proto.v1.AlignmentConfig.Extender.prototype.setDensity = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1, proto.v1.AlignmentConfig.Extender.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.v1.AlignmentConfig.Extender} returns this
 */
proto.v1.AlignmentConfig.Extender.prototype.clearDensity = function() {
  return this.setDensity(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.v1.AlignmentConfig.Extender.prototype.hasDensity = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional Range range = 2;
 * @return {?proto.v1.AlignmentConfig.Extender.Range}
 */
proto.v1.AlignmentConfig.Extender.prototype.getRange = function() {
  return /** @type{?proto.v1.AlignmentConfig.Extender.Range} */ (
    jspb.Message.getWrapperField(this, proto.v1.AlignmentConfig.Extender.Range, 2));
};


/**
 * @param {?proto.v1.AlignmentConfig.Extender.Range|undefined} value
 * @return {!proto.v1.AlignmentConfig.Extender} returns this
*/
proto.v1.AlignmentConfig.Extender.prototype.setRange = function(value) {
  return jspb.Message.setOneofWrapperField(this, 2, proto.v1.AlignmentConfig.Extender.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.v1.AlignmentConfig.Extender} returns this
 */
proto.v1.AlignmentConfig.Extender.prototype.clearRange = function() {
  return this.setRange(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.v1.AlignmentConfig.Extender.prototype.hasRange = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.v1.AlignmentConfig.Reducer.oneofGroups_ = [[1]];

/**
 * @enum {number}
 */
proto.v1.AlignmentConfig.Reducer.ReducerCase = {
  REDUCER_NOT_SET: 0,
  PASSAGE_LENGTH: 1
};

/**
 * @return {proto.v1.AlignmentConfig.Reducer.ReducerCase}
 */
proto.v1.AlignmentConfig.Reducer.prototype.getReducerCase = function() {
  return /** @type {proto.v1.AlignmentConfig.Reducer.ReducerCase} */(jspb.Message.computeOneofCase(this, proto.v1.AlignmentConfig.Reducer.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.v1.AlignmentConfig.Reducer.prototype.toObject = function(opt_includeInstance) {
  return proto.v1.AlignmentConfig.Reducer.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.v1.AlignmentConfig.Reducer} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Reducer.toObject = function(includeInstance, msg) {
  var f, obj = {
    passageLength: (f = msg.getPassageLength()) && proto.v1.AlignmentConfig.Reducer.PassageLength.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.v1.AlignmentConfig.Reducer}
 */
proto.v1.AlignmentConfig.Reducer.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.v1.AlignmentConfig.Reducer;
  return proto.v1.AlignmentConfig.Reducer.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.v1.AlignmentConfig.Reducer} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.v1.AlignmentConfig.Reducer}
 */
proto.v1.AlignmentConfig.Reducer.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.v1.AlignmentConfig.Reducer.PassageLength;
      reader.readMessage(value,proto.v1.AlignmentConfig.Reducer.PassageLength.deserializeBinaryFromReader);
      msg.setPassageLength(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.v1.AlignmentConfig.Reducer.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.v1.AlignmentConfig.Reducer.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.v1.AlignmentConfig.Reducer} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Reducer.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPassageLength();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.v1.AlignmentConfig.Reducer.PassageLength.serializeBinaryToWriter
    );
  }
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.v1.AlignmentConfig.Reducer.PassageLength.prototype.toObject = function(opt_includeInstance) {
  return proto.v1.AlignmentConfig.Reducer.PassageLength.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.v1.AlignmentConfig.Reducer.PassageLength} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Reducer.PassageLength.toObject = function(includeInstance, msg) {
  var f, obj = {
    minLength: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.v1.AlignmentConfig.Reducer.PassageLength}
 */
proto.v1.AlignmentConfig.Reducer.PassageLength.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.v1.AlignmentConfig.Reducer.PassageLength;
  return proto.v1.AlignmentConfig.Reducer.PassageLength.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.v1.AlignmentConfig.Reducer.PassageLength} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.v1.AlignmentConfig.Reducer.PassageLength}
 */
proto.v1.AlignmentConfig.Reducer.PassageLength.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMinLength(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.v1.AlignmentConfig.Reducer.PassageLength.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.v1.AlignmentConfig.Reducer.PassageLength.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.v1.AlignmentConfig.Reducer.PassageLength} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Reducer.PassageLength.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMinLength();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 min_length = 1;
 * @return {number}
 */
proto.v1.AlignmentConfig.Reducer.PassageLength.prototype.getMinLength = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.v1.AlignmentConfig.Reducer.PassageLength} returns this
 */
proto.v1.AlignmentConfig.Reducer.PassageLength.prototype.setMinLength = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional PassageLength passage_length = 1;
 * @return {?proto.v1.AlignmentConfig.Reducer.PassageLength}
 */
proto.v1.AlignmentConfig.Reducer.prototype.getPassageLength = function() {
  return /** @type{?proto.v1.AlignmentConfig.Reducer.PassageLength} */ (
    jspb.Message.getWrapperField(this, proto.v1.AlignmentConfig.Reducer.PassageLength, 1));
};


/**
 * @param {?proto.v1.AlignmentConfig.Reducer.PassageLength|undefined} value
 * @return {!proto.v1.AlignmentConfig.Reducer} returns this
*/
proto.v1.AlignmentConfig.Reducer.prototype.setPassageLength = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1, proto.v1.AlignmentConfig.Reducer.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.v1.AlignmentConfig.Reducer} returns this
 */
proto.v1.AlignmentConfig.Reducer.prototype.clearPassageLength = function() {
  return this.setPassageLength(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.v1.AlignmentConfig.Reducer.prototype.hasPassageLength = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.v1.AlignmentConfig.Similarity.oneofGroups_ = [[1,2,3,4]];

/**
 * @enum {number}
 */
proto.v1.AlignmentConfig.Similarity.SimilarityCase = {
  SIMILARITY_NOT_SET: 0,
  IDENTITY: 1,
  COSINE: 2,
  LEVENSHTEIN: 3,
  JACCARD: 4
};

/**
 * @return {proto.v1.AlignmentConfig.Similarity.SimilarityCase}
 */
proto.v1.AlignmentConfig.Similarity.prototype.getSimilarityCase = function() {
  return /** @type {proto.v1.AlignmentConfig.Similarity.SimilarityCase} */(jspb.Message.computeOneofCase(this, proto.v1.AlignmentConfig.Similarity.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.v1.AlignmentConfig.Similarity.prototype.toObject = function(opt_includeInstance) {
  return proto.v1.AlignmentConfig.Similarity.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.v1.AlignmentConfig.Similarity} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Similarity.toObject = function(includeInstance, msg) {
  var f, obj = {
    identity: (f = msg.getIdentity()) && proto.v1.AlignmentConfig.Similarity.Identity.toObject(includeInstance, f),
    cosine: (f = msg.getCosine()) && proto.v1.AlignmentConfig.Similarity.Cosine.toObject(includeInstance, f),
    levenshtein: (f = msg.getLevenshtein()) && proto.v1.AlignmentConfig.Similarity.Levenshtein.toObject(includeInstance, f),
    jaccard: (f = msg.getJaccard()) && proto.v1.AlignmentConfig.Similarity.Jaccard.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.v1.AlignmentConfig.Similarity}
 */
proto.v1.AlignmentConfig.Similarity.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.v1.AlignmentConfig.Similarity;
  return proto.v1.AlignmentConfig.Similarity.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.v1.AlignmentConfig.Similarity} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.v1.AlignmentConfig.Similarity}
 */
proto.v1.AlignmentConfig.Similarity.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.v1.AlignmentConfig.Similarity.Identity;
      reader.readMessage(value,proto.v1.AlignmentConfig.Similarity.Identity.deserializeBinaryFromReader);
      msg.setIdentity(value);
      break;
    case 2:
      var value = new proto.v1.AlignmentConfig.Similarity.Cosine;
      reader.readMessage(value,proto.v1.AlignmentConfig.Similarity.Cosine.deserializeBinaryFromReader);
      msg.setCosine(value);
      break;
    case 3:
      var value = new proto.v1.AlignmentConfig.Similarity.Levenshtein;
      reader.readMessage(value,proto.v1.AlignmentConfig.Similarity.Levenshtein.deserializeBinaryFromReader);
      msg.setLevenshtein(value);
      break;
    case 4:
      var value = new proto.v1.AlignmentConfig.Similarity.Jaccard;
      reader.readMessage(value,proto.v1.AlignmentConfig.Similarity.Jaccard.deserializeBinaryFromReader);
      msg.setJaccard(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.v1.AlignmentConfig.Similarity.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.v1.AlignmentConfig.Similarity.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.v1.AlignmentConfig.Similarity} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Similarity.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getIdentity();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.v1.AlignmentConfig.Similarity.Identity.serializeBinaryToWriter
    );
  }
  f = message.getCosine();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.v1.AlignmentConfig.Similarity.Cosine.serializeBinaryToWriter
    );
  }
  f = message.getLevenshtein();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.v1.AlignmentConfig.Similarity.Levenshtein.serializeBinaryToWriter
    );
  }
  f = message.getJaccard();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.v1.AlignmentConfig.Similarity.Jaccard.serializeBinaryToWriter
    );
  }
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.v1.AlignmentConfig.Similarity.Identity.prototype.toObject = function(opt_includeInstance) {
  return proto.v1.AlignmentConfig.Similarity.Identity.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.v1.AlignmentConfig.Similarity.Identity} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Similarity.Identity.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.v1.AlignmentConfig.Similarity.Identity}
 */
proto.v1.AlignmentConfig.Similarity.Identity.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.v1.AlignmentConfig.Similarity.Identity;
  return proto.v1.AlignmentConfig.Similarity.Identity.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.v1.AlignmentConfig.Similarity.Identity} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.v1.AlignmentConfig.Similarity.Identity}
 */
proto.v1.AlignmentConfig.Similarity.Identity.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.v1.AlignmentConfig.Similarity.Identity.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.v1.AlignmentConfig.Similarity.Identity.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.v1.AlignmentConfig.Similarity.Identity} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Similarity.Identity.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.v1.AlignmentConfig.Similarity.Cosine.prototype.toObject = function(opt_includeInstance) {
  return proto.v1.AlignmentConfig.Similarity.Cosine.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.v1.AlignmentConfig.Similarity.Cosine} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Similarity.Cosine.toObject = function(includeInstance, msg) {
  var f, obj = {
    threshold: jspb.Message.getFloatingPointFieldWithDefault(msg, 1, 0.0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.v1.AlignmentConfig.Similarity.Cosine}
 */
proto.v1.AlignmentConfig.Similarity.Cosine.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.v1.AlignmentConfig.Similarity.Cosine;
  return proto.v1.AlignmentConfig.Similarity.Cosine.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.v1.AlignmentConfig.Similarity.Cosine} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.v1.AlignmentConfig.Similarity.Cosine}
 */
proto.v1.AlignmentConfig.Similarity.Cosine.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setThreshold(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.v1.AlignmentConfig.Similarity.Cosine.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.v1.AlignmentConfig.Similarity.Cosine.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.v1.AlignmentConfig.Similarity.Cosine} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Similarity.Cosine.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getThreshold();
  if (f !== 0.0) {
    writer.writeFloat(
      1,
      f
    );
  }
};


/**
 * optional float threshold = 1;
 * @return {number}
 */
proto.v1.AlignmentConfig.Similarity.Cosine.prototype.getThreshold = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 1, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.v1.AlignmentConfig.Similarity.Cosine} returns this
 */
proto.v1.AlignmentConfig.Similarity.Cosine.prototype.setThreshold = function(value) {
  return jspb.Message.setProto3FloatField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.v1.AlignmentConfig.Similarity.Levenshtein.prototype.toObject = function(opt_includeInstance) {
  return proto.v1.AlignmentConfig.Similarity.Levenshtein.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.v1.AlignmentConfig.Similarity.Levenshtein} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Similarity.Levenshtein.toObject = function(includeInstance, msg) {
  var f, obj = {
    threshold: jspb.Message.getFloatingPointFieldWithDefault(msg, 1, 0.0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.v1.AlignmentConfig.Similarity.Levenshtein}
 */
proto.v1.AlignmentConfig.Similarity.Levenshtein.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.v1.AlignmentConfig.Similarity.Levenshtein;
  return proto.v1.AlignmentConfig.Similarity.Levenshtein.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.v1.AlignmentConfig.Similarity.Levenshtein} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.v1.AlignmentConfig.Similarity.Levenshtein}
 */
proto.v1.AlignmentConfig.Similarity.Levenshtein.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setThreshold(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.v1.AlignmentConfig.Similarity.Levenshtein.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.v1.AlignmentConfig.Similarity.Levenshtein.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.v1.AlignmentConfig.Similarity.Levenshtein} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Similarity.Levenshtein.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getThreshold();
  if (f !== 0.0) {
    writer.writeFloat(
      1,
      f
    );
  }
};


/**
 * optional float threshold = 1;
 * @return {number}
 */
proto.v1.AlignmentConfig.Similarity.Levenshtein.prototype.getThreshold = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 1, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.v1.AlignmentConfig.Similarity.Levenshtein} returns this
 */
proto.v1.AlignmentConfig.Similarity.Levenshtein.prototype.setThreshold = function(value) {
  return jspb.Message.setProto3FloatField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.v1.AlignmentConfig.Similarity.Jaccard.prototype.toObject = function(opt_includeInstance) {
  return proto.v1.AlignmentConfig.Similarity.Jaccard.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.v1.AlignmentConfig.Similarity.Jaccard} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Similarity.Jaccard.toObject = function(includeInstance, msg) {
  var f, obj = {
    threshold: jspb.Message.getFloatingPointFieldWithDefault(msg, 1, 0.0),
    separator: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.v1.AlignmentConfig.Similarity.Jaccard}
 */
proto.v1.AlignmentConfig.Similarity.Jaccard.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.v1.AlignmentConfig.Similarity.Jaccard;
  return proto.v1.AlignmentConfig.Similarity.Jaccard.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.v1.AlignmentConfig.Similarity.Jaccard} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.v1.AlignmentConfig.Similarity.Jaccard}
 */
proto.v1.AlignmentConfig.Similarity.Jaccard.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setThreshold(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setSeparator(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.v1.AlignmentConfig.Similarity.Jaccard.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.v1.AlignmentConfig.Similarity.Jaccard.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.v1.AlignmentConfig.Similarity.Jaccard} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Similarity.Jaccard.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getThreshold();
  if (f !== 0.0) {
    writer.writeFloat(
      1,
      f
    );
  }
  f = message.getSeparator();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional float threshold = 1;
 * @return {number}
 */
proto.v1.AlignmentConfig.Similarity.Jaccard.prototype.getThreshold = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 1, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.v1.AlignmentConfig.Similarity.Jaccard} returns this
 */
proto.v1.AlignmentConfig.Similarity.Jaccard.prototype.setThreshold = function(value) {
  return jspb.Message.setProto3FloatField(this, 1, value);
};


/**
 * optional string separator = 2;
 * @return {string}
 */
proto.v1.AlignmentConfig.Similarity.Jaccard.prototype.getSeparator = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.v1.AlignmentConfig.Similarity.Jaccard} returns this
 */
proto.v1.AlignmentConfig.Similarity.Jaccard.prototype.setSeparator = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional Identity identity = 1;
 * @return {?proto.v1.AlignmentConfig.Similarity.Identity}
 */
proto.v1.AlignmentConfig.Similarity.prototype.getIdentity = function() {
  return /** @type{?proto.v1.AlignmentConfig.Similarity.Identity} */ (
    jspb.Message.getWrapperField(this, proto.v1.AlignmentConfig.Similarity.Identity, 1));
};


/**
 * @param {?proto.v1.AlignmentConfig.Similarity.Identity|undefined} value
 * @return {!proto.v1.AlignmentConfig.Similarity} returns this
*/
proto.v1.AlignmentConfig.Similarity.prototype.setIdentity = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1, proto.v1.AlignmentConfig.Similarity.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.v1.AlignmentConfig.Similarity} returns this
 */
proto.v1.AlignmentConfig.Similarity.prototype.clearIdentity = function() {
  return this.setIdentity(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.v1.AlignmentConfig.Similarity.prototype.hasIdentity = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional Cosine cosine = 2;
 * @return {?proto.v1.AlignmentConfig.Similarity.Cosine}
 */
proto.v1.AlignmentConfig.Similarity.prototype.getCosine = function() {
  return /** @type{?proto.v1.AlignmentConfig.Similarity.Cosine} */ (
    jspb.Message.getWrapperField(this, proto.v1.AlignmentConfig.Similarity.Cosine, 2));
};


/**
 * @param {?proto.v1.AlignmentConfig.Similarity.Cosine|undefined} value
 * @return {!proto.v1.AlignmentConfig.Similarity} returns this
*/
proto.v1.AlignmentConfig.Similarity.prototype.setCosine = function(value) {
  return jspb.Message.setOneofWrapperField(this, 2, proto.v1.AlignmentConfig.Similarity.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.v1.AlignmentConfig.Similarity} returns this
 */
proto.v1.AlignmentConfig.Similarity.prototype.clearCosine = function() {
  return this.setCosine(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.v1.AlignmentConfig.Similarity.prototype.hasCosine = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional Levenshtein levenshtein = 3;
 * @return {?proto.v1.AlignmentConfig.Similarity.Levenshtein}
 */
proto.v1.AlignmentConfig.Similarity.prototype.getLevenshtein = function() {
  return /** @type{?proto.v1.AlignmentConfig.Similarity.Levenshtein} */ (
    jspb.Message.getWrapperField(this, proto.v1.AlignmentConfig.Similarity.Levenshtein, 3));
};


/**
 * @param {?proto.v1.AlignmentConfig.Similarity.Levenshtein|undefined} value
 * @return {!proto.v1.AlignmentConfig.Similarity} returns this
*/
proto.v1.AlignmentConfig.Similarity.prototype.setLevenshtein = function(value) {
  return jspb.Message.setOneofWrapperField(this, 3, proto.v1.AlignmentConfig.Similarity.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.v1.AlignmentConfig.Similarity} returns this
 */
proto.v1.AlignmentConfig.Similarity.prototype.clearLevenshtein = function() {
  return this.setLevenshtein(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.v1.AlignmentConfig.Similarity.prototype.hasLevenshtein = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional Jaccard jaccard = 4;
 * @return {?proto.v1.AlignmentConfig.Similarity.Jaccard}
 */
proto.v1.AlignmentConfig.Similarity.prototype.getJaccard = function() {
  return /** @type{?proto.v1.AlignmentConfig.Similarity.Jaccard} */ (
    jspb.Message.getWrapperField(this, proto.v1.AlignmentConfig.Similarity.Jaccard, 4));
};


/**
 * @param {?proto.v1.AlignmentConfig.Similarity.Jaccard|undefined} value
 * @return {!proto.v1.AlignmentConfig.Similarity} returns this
*/
proto.v1.AlignmentConfig.Similarity.prototype.setJaccard = function(value) {
  return jspb.Message.setOneofWrapperField(this, 4, proto.v1.AlignmentConfig.Similarity.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.v1.AlignmentConfig.Similarity} returns this
 */
proto.v1.AlignmentConfig.Similarity.prototype.clearJaccard = function() {
  return this.setJaccard(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.v1.AlignmentConfig.Similarity.prototype.hasJaccard = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.v1.AlignmentConfig.Combinator.oneofGroups_ = [[1,2]];

/**
 * @enum {number}
 */
proto.v1.AlignmentConfig.Combinator.CombinatorCase = {
  COMBINATOR_NOT_SET: 0,
  STRING_CONCAT: 1,
  VECTOR_CONCAT: 2
};

/**
 * @return {proto.v1.AlignmentConfig.Combinator.CombinatorCase}
 */
proto.v1.AlignmentConfig.Combinator.prototype.getCombinatorCase = function() {
  return /** @type {proto.v1.AlignmentConfig.Combinator.CombinatorCase} */(jspb.Message.computeOneofCase(this, proto.v1.AlignmentConfig.Combinator.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.v1.AlignmentConfig.Combinator.prototype.toObject = function(opt_includeInstance) {
  return proto.v1.AlignmentConfig.Combinator.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.v1.AlignmentConfig.Combinator} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Combinator.toObject = function(includeInstance, msg) {
  var f, obj = {
    stringConcat: (f = msg.getStringConcat()) && proto.v1.AlignmentConfig.Combinator.StringConcat.toObject(includeInstance, f),
    vectorConcat: (f = msg.getVectorConcat()) && proto.v1.AlignmentConfig.Combinator.VectorConcat.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.v1.AlignmentConfig.Combinator}
 */
proto.v1.AlignmentConfig.Combinator.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.v1.AlignmentConfig.Combinator;
  return proto.v1.AlignmentConfig.Combinator.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.v1.AlignmentConfig.Combinator} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.v1.AlignmentConfig.Combinator}
 */
proto.v1.AlignmentConfig.Combinator.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.v1.AlignmentConfig.Combinator.StringConcat;
      reader.readMessage(value,proto.v1.AlignmentConfig.Combinator.StringConcat.deserializeBinaryFromReader);
      msg.setStringConcat(value);
      break;
    case 2:
      var value = new proto.v1.AlignmentConfig.Combinator.VectorConcat;
      reader.readMessage(value,proto.v1.AlignmentConfig.Combinator.VectorConcat.deserializeBinaryFromReader);
      msg.setVectorConcat(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.v1.AlignmentConfig.Combinator.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.v1.AlignmentConfig.Combinator.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.v1.AlignmentConfig.Combinator} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Combinator.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getStringConcat();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.v1.AlignmentConfig.Combinator.StringConcat.serializeBinaryToWriter
    );
  }
  f = message.getVectorConcat();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.v1.AlignmentConfig.Combinator.VectorConcat.serializeBinaryToWriter
    );
  }
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.v1.AlignmentConfig.Combinator.StringConcat.prototype.toObject = function(opt_includeInstance) {
  return proto.v1.AlignmentConfig.Combinator.StringConcat.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.v1.AlignmentConfig.Combinator.StringConcat} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Combinator.StringConcat.toObject = function(includeInstance, msg) {
  var f, obj = {
    sep: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.v1.AlignmentConfig.Combinator.StringConcat}
 */
proto.v1.AlignmentConfig.Combinator.StringConcat.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.v1.AlignmentConfig.Combinator.StringConcat;
  return proto.v1.AlignmentConfig.Combinator.StringConcat.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.v1.AlignmentConfig.Combinator.StringConcat} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.v1.AlignmentConfig.Combinator.StringConcat}
 */
proto.v1.AlignmentConfig.Combinator.StringConcat.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setSep(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.v1.AlignmentConfig.Combinator.StringConcat.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.v1.AlignmentConfig.Combinator.StringConcat.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.v1.AlignmentConfig.Combinator.StringConcat} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Combinator.StringConcat.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSep();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string sep = 1;
 * @return {string}
 */
proto.v1.AlignmentConfig.Combinator.StringConcat.prototype.getSep = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.v1.AlignmentConfig.Combinator.StringConcat} returns this
 */
proto.v1.AlignmentConfig.Combinator.StringConcat.prototype.setSep = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.v1.AlignmentConfig.Combinator.VectorConcat.prototype.toObject = function(opt_includeInstance) {
  return proto.v1.AlignmentConfig.Combinator.VectorConcat.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.v1.AlignmentConfig.Combinator.VectorConcat} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Combinator.VectorConcat.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.v1.AlignmentConfig.Combinator.VectorConcat}
 */
proto.v1.AlignmentConfig.Combinator.VectorConcat.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.v1.AlignmentConfig.Combinator.VectorConcat;
  return proto.v1.AlignmentConfig.Combinator.VectorConcat.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.v1.AlignmentConfig.Combinator.VectorConcat} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.v1.AlignmentConfig.Combinator.VectorConcat}
 */
proto.v1.AlignmentConfig.Combinator.VectorConcat.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.v1.AlignmentConfig.Combinator.VectorConcat.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.v1.AlignmentConfig.Combinator.VectorConcat.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.v1.AlignmentConfig.Combinator.VectorConcat} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Combinator.VectorConcat.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};


/**
 * optional StringConcat string_concat = 1;
 * @return {?proto.v1.AlignmentConfig.Combinator.StringConcat}
 */
proto.v1.AlignmentConfig.Combinator.prototype.getStringConcat = function() {
  return /** @type{?proto.v1.AlignmentConfig.Combinator.StringConcat} */ (
    jspb.Message.getWrapperField(this, proto.v1.AlignmentConfig.Combinator.StringConcat, 1));
};


/**
 * @param {?proto.v1.AlignmentConfig.Combinator.StringConcat|undefined} value
 * @return {!proto.v1.AlignmentConfig.Combinator} returns this
*/
proto.v1.AlignmentConfig.Combinator.prototype.setStringConcat = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1, proto.v1.AlignmentConfig.Combinator.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.v1.AlignmentConfig.Combinator} returns this
 */
proto.v1.AlignmentConfig.Combinator.prototype.clearStringConcat = function() {
  return this.setStringConcat(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.v1.AlignmentConfig.Combinator.prototype.hasStringConcat = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional VectorConcat vector_concat = 2;
 * @return {?proto.v1.AlignmentConfig.Combinator.VectorConcat}
 */
proto.v1.AlignmentConfig.Combinator.prototype.getVectorConcat = function() {
  return /** @type{?proto.v1.AlignmentConfig.Combinator.VectorConcat} */ (
    jspb.Message.getWrapperField(this, proto.v1.AlignmentConfig.Combinator.VectorConcat, 2));
};


/**
 * @param {?proto.v1.AlignmentConfig.Combinator.VectorConcat|undefined} value
 * @return {!proto.v1.AlignmentConfig.Combinator} returns this
*/
proto.v1.AlignmentConfig.Combinator.prototype.setVectorConcat = function(value) {
  return jspb.Message.setOneofWrapperField(this, 2, proto.v1.AlignmentConfig.Combinator.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.v1.AlignmentConfig.Combinator} returns this
 */
proto.v1.AlignmentConfig.Combinator.prototype.clearVectorConcat = function() {
  return this.setVectorConcat(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.v1.AlignmentConfig.Combinator.prototype.hasVectorConcat = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.v1.AlignmentConfig.Normalizer.oneofGroups_ = [[1]];

/**
 * @enum {number}
 */
proto.v1.AlignmentConfig.Normalizer.NormalizerCase = {
  NORMALIZER_NOT_SET: 0,
  SORTING: 1
};

/**
 * @return {proto.v1.AlignmentConfig.Normalizer.NormalizerCase}
 */
proto.v1.AlignmentConfig.Normalizer.prototype.getNormalizerCase = function() {
  return /** @type {proto.v1.AlignmentConfig.Normalizer.NormalizerCase} */(jspb.Message.computeOneofCase(this, proto.v1.AlignmentConfig.Normalizer.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.v1.AlignmentConfig.Normalizer.prototype.toObject = function(opt_includeInstance) {
  return proto.v1.AlignmentConfig.Normalizer.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.v1.AlignmentConfig.Normalizer} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Normalizer.toObject = function(includeInstance, msg) {
  var f, obj = {
    sorting: (f = msg.getSorting()) && proto.v1.AlignmentConfig.Normalizer.Sorting.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.v1.AlignmentConfig.Normalizer}
 */
proto.v1.AlignmentConfig.Normalizer.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.v1.AlignmentConfig.Normalizer;
  return proto.v1.AlignmentConfig.Normalizer.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.v1.AlignmentConfig.Normalizer} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.v1.AlignmentConfig.Normalizer}
 */
proto.v1.AlignmentConfig.Normalizer.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.v1.AlignmentConfig.Normalizer.Sorting;
      reader.readMessage(value,proto.v1.AlignmentConfig.Normalizer.Sorting.deserializeBinaryFromReader);
      msg.setSorting(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.v1.AlignmentConfig.Normalizer.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.v1.AlignmentConfig.Normalizer.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.v1.AlignmentConfig.Normalizer} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Normalizer.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSorting();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.v1.AlignmentConfig.Normalizer.Sorting.serializeBinaryToWriter
    );
  }
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.v1.AlignmentConfig.Normalizer.Sorting.prototype.toObject = function(opt_includeInstance) {
  return proto.v1.AlignmentConfig.Normalizer.Sorting.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.v1.AlignmentConfig.Normalizer.Sorting} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Normalizer.Sorting.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.v1.AlignmentConfig.Normalizer.Sorting}
 */
proto.v1.AlignmentConfig.Normalizer.Sorting.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.v1.AlignmentConfig.Normalizer.Sorting;
  return proto.v1.AlignmentConfig.Normalizer.Sorting.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.v1.AlignmentConfig.Normalizer.Sorting} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.v1.AlignmentConfig.Normalizer.Sorting}
 */
proto.v1.AlignmentConfig.Normalizer.Sorting.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.v1.AlignmentConfig.Normalizer.Sorting.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.v1.AlignmentConfig.Normalizer.Sorting.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.v1.AlignmentConfig.Normalizer.Sorting} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.AlignmentConfig.Normalizer.Sorting.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};


/**
 * optional Sorting sorting = 1;
 * @return {?proto.v1.AlignmentConfig.Normalizer.Sorting}
 */
proto.v1.AlignmentConfig.Normalizer.prototype.getSorting = function() {
  return /** @type{?proto.v1.AlignmentConfig.Normalizer.Sorting} */ (
    jspb.Message.getWrapperField(this, proto.v1.AlignmentConfig.Normalizer.Sorting, 1));
};


/**
 * @param {?proto.v1.AlignmentConfig.Normalizer.Sorting|undefined} value
 * @return {!proto.v1.AlignmentConfig.Normalizer} returns this
*/
proto.v1.AlignmentConfig.Normalizer.prototype.setSorting = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1, proto.v1.AlignmentConfig.Normalizer.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.v1.AlignmentConfig.Normalizer} returns this
 */
proto.v1.AlignmentConfig.Normalizer.prototype.clearSorting = function() {
  return this.setSorting(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.v1.AlignmentConfig.Normalizer.prototype.hasSorting = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional Mode mode = 1;
 * @return {!proto.v1.AlignmentConfig.Mode}
 */
proto.v1.AlignmentConfig.prototype.getMode = function() {
  return /** @type {!proto.v1.AlignmentConfig.Mode} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.v1.AlignmentConfig.Mode} value
 * @return {!proto.v1.AlignmentConfig} returns this
 */
proto.v1.AlignmentConfig.prototype.setMode = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional Seeder seeder = 2;
 * @return {?proto.v1.AlignmentConfig.Seeder}
 */
proto.v1.AlignmentConfig.prototype.getSeeder = function() {
  return /** @type{?proto.v1.AlignmentConfig.Seeder} */ (
    jspb.Message.getWrapperField(this, proto.v1.AlignmentConfig.Seeder, 2));
};


/**
 * @param {?proto.v1.AlignmentConfig.Seeder|undefined} value
 * @return {!proto.v1.AlignmentConfig} returns this
*/
proto.v1.AlignmentConfig.prototype.setSeeder = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.v1.AlignmentConfig} returns this
 */
proto.v1.AlignmentConfig.prototype.clearSeeder = function() {
  return this.setSeeder(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.v1.AlignmentConfig.prototype.hasSeeder = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional Extender extender = 3;
 * @return {?proto.v1.AlignmentConfig.Extender}
 */
proto.v1.AlignmentConfig.prototype.getExtender = function() {
  return /** @type{?proto.v1.AlignmentConfig.Extender} */ (
    jspb.Message.getWrapperField(this, proto.v1.AlignmentConfig.Extender, 3));
};


/**
 * @param {?proto.v1.AlignmentConfig.Extender|undefined} value
 * @return {!proto.v1.AlignmentConfig} returns this
*/
proto.v1.AlignmentConfig.prototype.setExtender = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.v1.AlignmentConfig} returns this
 */
proto.v1.AlignmentConfig.prototype.clearExtender = function() {
  return this.setExtender(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.v1.AlignmentConfig.prototype.hasExtender = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional Reducer reducer = 4;
 * @return {?proto.v1.AlignmentConfig.Reducer}
 */
proto.v1.AlignmentConfig.prototype.getReducer = function() {
  return /** @type{?proto.v1.AlignmentConfig.Reducer} */ (
    jspb.Message.getWrapperField(this, proto.v1.AlignmentConfig.Reducer, 4));
};


/**
 * @param {?proto.v1.AlignmentConfig.Reducer|undefined} value
 * @return {!proto.v1.AlignmentConfig} returns this
*/
proto.v1.AlignmentConfig.prototype.setReducer = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.v1.AlignmentConfig} returns this
 */
proto.v1.AlignmentConfig.prototype.clearReducer = function() {
  return this.setReducer(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.v1.AlignmentConfig.prototype.hasReducer = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional Similarity similarity = 5;
 * @return {?proto.v1.AlignmentConfig.Similarity}
 */
proto.v1.AlignmentConfig.prototype.getSimilarity = function() {
  return /** @type{?proto.v1.AlignmentConfig.Similarity} */ (
    jspb.Message.getWrapperField(this, proto.v1.AlignmentConfig.Similarity, 5));
};


/**
 * @param {?proto.v1.AlignmentConfig.Similarity|undefined} value
 * @return {!proto.v1.AlignmentConfig} returns this
*/
proto.v1.AlignmentConfig.prototype.setSimilarity = function(value) {
  return jspb.Message.setWrapperField(this, 5, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.v1.AlignmentConfig} returns this
 */
proto.v1.AlignmentConfig.prototype.clearSimilarity = function() {
  return this.setSimilarity(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.v1.AlignmentConfig.prototype.hasSimilarity = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional Combinator combinator = 6;
 * @return {?proto.v1.AlignmentConfig.Combinator}
 */
proto.v1.AlignmentConfig.prototype.getCombinator = function() {
  return /** @type{?proto.v1.AlignmentConfig.Combinator} */ (
    jspb.Message.getWrapperField(this, proto.v1.AlignmentConfig.Combinator, 6));
};


/**
 * @param {?proto.v1.AlignmentConfig.Combinator|undefined} value
 * @return {!proto.v1.AlignmentConfig} returns this
*/
proto.v1.AlignmentConfig.prototype.setCombinator = function(value) {
  return jspb.Message.setWrapperField(this, 6, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.v1.AlignmentConfig} returns this
 */
proto.v1.AlignmentConfig.prototype.clearCombinator = function() {
  return this.setCombinator(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.v1.AlignmentConfig.prototype.hasCombinator = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional Normalizer normalizer = 7;
 * @return {?proto.v1.AlignmentConfig.Normalizer}
 */
proto.v1.AlignmentConfig.prototype.getNormalizer = function() {
  return /** @type{?proto.v1.AlignmentConfig.Normalizer} */ (
    jspb.Message.getWrapperField(this, proto.v1.AlignmentConfig.Normalizer, 7));
};


/**
 * @param {?proto.v1.AlignmentConfig.Normalizer|undefined} value
 * @return {!proto.v1.AlignmentConfig} returns this
*/
proto.v1.AlignmentConfig.prototype.setNormalizer = function(value) {
  return jspb.Message.setWrapperField(this, 7, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.v1.AlignmentConfig} returns this
 */
proto.v1.AlignmentConfig.prototype.clearNormalizer = function() {
  return this.setNormalizer(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.v1.AlignmentConfig.prototype.hasNormalizer = function() {
  return jspb.Message.getField(this, 7) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.v1.SessionConfig.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.v1.SessionConfig.prototype.toObject = function(opt_includeInstance) {
  return proto.v1.SessionConfig.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.v1.SessionConfig} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.SessionConfig.toObject = function(includeInstance, msg) {
  var f, obj = {
    config: (f = msg.getConfig()) && proto.v1.ApiConfig.toObject(includeInstance, f),
    pairingsList: jspb.Message.toObjectList(msg.getPairingsList(),
    v1_types_pb.ResourcePair.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.v1.SessionConfig}
 */
proto.v1.SessionConfig.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.v1.SessionConfig;
  return proto.v1.SessionConfig.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.v1.SessionConfig} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.v1.SessionConfig}
 */
proto.v1.SessionConfig.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.v1.ApiConfig;
      reader.readMessage(value,proto.v1.ApiConfig.deserializeBinaryFromReader);
      msg.setConfig(value);
      break;
    case 2:
      var value = new v1_types_pb.ResourcePair;
      reader.readMessage(value,v1_types_pb.ResourcePair.deserializeBinaryFromReader);
      msg.addPairings(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.v1.SessionConfig.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.v1.SessionConfig.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.v1.SessionConfig} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.v1.SessionConfig.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getConfig();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.v1.ApiConfig.serializeBinaryToWriter
    );
  }
  f = message.getPairingsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      v1_types_pb.ResourcePair.serializeBinaryToWriter
    );
  }
};


/**
 * optional ApiConfig config = 1;
 * @return {?proto.v1.ApiConfig}
 */
proto.v1.SessionConfig.prototype.getConfig = function() {
  return /** @type{?proto.v1.ApiConfig} */ (
    jspb.Message.getWrapperField(this, proto.v1.ApiConfig, 1));
};


/**
 * @param {?proto.v1.ApiConfig|undefined} value
 * @return {!proto.v1.SessionConfig} returns this
*/
proto.v1.SessionConfig.prototype.setConfig = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.v1.SessionConfig} returns this
 */
proto.v1.SessionConfig.prototype.clearConfig = function() {
  return this.setConfig(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.v1.SessionConfig.prototype.hasConfig = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * repeated ResourcePair pairings = 2;
 * @return {!Array<!proto.v1.ResourcePair>}
 */
proto.v1.SessionConfig.prototype.getPairingsList = function() {
  return /** @type{!Array<!proto.v1.ResourcePair>} */ (
    jspb.Message.getRepeatedWrapperField(this, v1_types_pb.ResourcePair, 2));
};


/**
 * @param {!Array<!proto.v1.ResourcePair>} value
 * @return {!proto.v1.SessionConfig} returns this
*/
proto.v1.SessionConfig.prototype.setPairingsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.v1.ResourcePair=} opt_value
 * @param {number=} opt_index
 * @return {!proto.v1.ResourcePair}
 */
proto.v1.SessionConfig.prototype.addPairings = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.v1.ResourcePair, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.v1.SessionConfig} returns this
 */
proto.v1.SessionConfig.prototype.clearPairingsList = function() {
  return this.setPairingsList([]);
};


goog.object.extend(exports, proto.v1);
